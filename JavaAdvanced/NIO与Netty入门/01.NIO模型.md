# NIO 模型

------

## 本节概述

了解 NIO 模型

## 主要内容

### 服务器通信原理

#### Socket通信模式

<img src="picture/01.NIO%E6%A8%A1%E5%9E%8B/image-20210323181525307.png" alt="image-20210323181525307" style="zoom:50%;" />

使用 IP + 端口号，区分具体的 Socket 通信。（IP：邮编，端口：门牌号）

那么，什么是端口号？

端口号是用于区分通信时，所访问的计算机的进程具体是哪个，或者说是具体访问的什么服务



在了解 IO 模型前，我们需要先了解阻塞、非阻塞、同步、异步之间关系。

阻塞、非阻塞
阻塞、非阻塞是线程处理模式，一般用在底层系统调用上。
		阻塞：线程未满足条件会被阻塞，进入 sleep 状态，即时间片还未到就让出 CPU 。
		非阻塞：计算未满足条件也直接返回。

同步、异步有什么关系
同步、异步是通信模式，指的是是否需要等待方法的调用执行完毕。
		同步其实就是一条道写下来，异步则是需要回调、事件等方式来实现后面的逻辑。

进程缓冲区、内核缓冲区
缓冲区的目的，是为了减少频繁的系统IO调用。大家都知道，系统调用需要保存之前的进程数据和状态等信息，而结束调用之后回来还需要恢复之前的信息，为了减少这种损耗时间、也损耗性能的系统调用，于是出现了缓冲区。
有了缓冲区，操作系统使用read函数把数据从内核缓冲区复制到进程缓冲区，write把数据从进程缓冲区复制到内核缓冲区中。等待缓冲区达到一定数量的时候，再进行IO的调用，提升性能。至于什么时候读取和存储则由内核来决定，用户程序不需要关心。
此处需要额外注意：**read 系统调用，并不是把数据直接从物理设备读到内存。write 系统调用，也不是直接把数据写入到物理设备。**





### 五种 IO 模型

<img src="picture/01.NIO%E6%A8%A1%E5%9E%8B/image-20210301154333373.png" alt="image-20210301154333373" style="zoom:30%;" />

#### IO 模型01 

**阻塞式IO**、**BIO**

<img src="picture/01.NIO%E6%A8%A1%E5%9E%8B/image-20210301161310375.png" alt="image-20210301161310375" style="zoom: 25%;" />

<img src="picture/01.NIO%E6%A8%A1%E5%9E%8B/image-20210301161527167.png" alt="image-20210301161527167" style="zoom:50%;" />

一般通过在 while(true) 循环中服务端会调用 accept() 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端的连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接。

#### IO 模型02

**非阻塞式IO**

<img src="picture/01.NIO%E6%A8%A1%E5%9E%8B/image-20210301163516186.png" alt="image-20210301163516186" style="zoom: 33%;" />

<img src="picture/01.NIO%E6%A8%A1%E5%9E%8B/image-20210301163654817.png" alt="image-20210301163654817" style="zoom:29%;" />

- 和阻塞IO类比，内核会立即返回，返回后获得足够的CPU时间继续做其他的事情。
- 用户进程第一个阶段不是阻塞的，需要不断的主动询问内核数据好了没有；第二个阶段总是阻塞的。

#### IO 模型03

**IO多路复用（IO multiplexing）**，也称事件驱动IO（event-driven IO），就是在单个线程里同时监控多个套接字，通过 select 和 poll 轮询所负责的所有 socket，当某个 socket 有数据到达了，就通知用户进程。

IO 复用同非阻塞 IO 本质一样，不过利用了新的 select 系统调用，**由内核来负责本来是请求进程该做的轮询操作**。看似比非阻塞 IO 还多了一个系统调用开销，不过因为可以支持多路 IO，才算提高了效率。

进程先是阻塞在 select/poll 上，再是阻塞在读操作的第二个阶段上。

<img src="picture/01.NIO%E6%A8%A1%E5%9E%8B/image-20210301164028761.png" alt="image-20210301164028761" style="zoom:33%;" />

<img src="picture/01.NIO%E6%A8%A1%E5%9E%8B/image-20210301164056576.png" alt="image-20210301164056576" style="zoom:45%;" />

 select/poll 的几大缺点：

（1）每次调用 select，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大

（2）同时每次调用 select 都需要在内核遍历传递进来的所有 fd，这个开销在 fd 很多时也很大

（3）select 支持的文件描述符（FileDescriptor--fd）数量太小了，默认是1024 

epoll（Linux 2.5.44内核中引入,2.6内核正式引入,可被用于代替 POSIX select 和 poll 系统调用）：

（1）内核与用户空间共享一块内存

（2）通过回调解决遍历问题

（3）fd 没有限制，可以支撑10万连接

<img src="picture/01.NIO%E6%A8%A1%E5%9E%8B/image-20210301164307767.png" alt="image-20210301164307767" style="zoom:33%;" />

<img src="picture/01.NIO%E6%A8%A1%E5%9E%8B/image-20210301164343948.png" alt="image-20210301164343948" style="zoom:33%;" />

#### IO 模型04

**信号驱动 I/O**

信号驱动 IO 与 BIO 和 NIO 最大的区别就在于，在IO执行的数据准备阶段，不会阻塞用户进程。 

如图所示：当用户进程需要等待数据的时候，会向内核发送一个信号，告诉内核我要什么数据，然后用户进程就继续做别的事情去了，而当内核中的数据准备好之后，内核立马发给用户进程一个信号，说“数据准备好了，快来查收”，用户进程收到信号之后，立马调用 recvfrom，去查收数据。

<img src="picture/01.NIO%E6%A8%A1%E5%9E%8B/image-20210301155905350.png" alt="image-20210301155905350" style="zoom: 30%;" />

##### 高性能高并发服务器底层的线程模型的发展脉络

线程池 -> EDA（事件驱动架构） -> SEDA（分阶段的事件驱动架构）
						（大小可控制）                （多级）



#### IO 模型05

**异步式IO**

异步 IO 真正实现了 IO 全流程的非阻塞，用户进程发出系统调用后立即返回，内核等待数据准备完成，然后将数据拷贝到用户进程缓冲区，然后发送信号告诉用户进程 IO 操作执行完毕（与 SIGIO 相比，一个是发送信号告诉用户进程数据准备完毕，一个是 IO 执行完毕）。

<img src="picture/01.NIO%E6%A8%A1%E5%9E%8B/image-20210301164436004.png" alt="image-20210301164436004" style="zoom:33%;" />

<img src="picture/01.NIO%E6%A8%A1%E5%9E%8B/image-20210301164529007.png" alt="image-20210301164529007" style="zoom:33%;" />



## 本节总结

**IO模型01**：

同步阻塞式IO，一个线程干到底，线程不是与网络打交道，而是与内核打交道。从内核走驱动发出请求。

**IO模型02**：
		一阶段是不阻塞的，需要不断的主动询问内核数据好了没有
		二阶段属于阻塞式IO

**IO模型03**：

IO多路复用，完全不需要中间长时间的等待过程

**IO模型04**：

事件驱动

**IO模型05**：

异步式IO，纯理论看，此模型性能最好

**模拟场景**
去打印店打印文件。
同步阻塞
直接排队，别的啥也干不成，直到轮到你使用打印机了，自己打印文件
Reactor -- IO多路复用epoll
拿个号码，回去该干嘛干嘛，等轮到你使用打印机了，店主通知你来用打印机，打印文件
Proactor -- 异步式IO
拿个号码，回去该干嘛干嘛，等轮到你使用打印机了，店主直接给你打印好文件，通知你来拿。



## 知识拓展

### 相关文章推荐

### 知识点拓展

【文件描述符】简称 fd，是一个用于表述指向文件的引用的抽象化概念。是一个索引值，在形式上是一个非负整数，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。

【Java 服务端处理网络请求的典型过程】

1. 客户端请求
    Linux 通过网卡，读取客户端的请求数据，将数据读取到内核缓冲区。
2. 获取请求数据
    服务器从内核缓冲区读取数据到 Java 进程缓冲区
3. 服务器端业务处理
    Java 服务端在自己的用户空间中，处理客户端的请求
4. 服务器端返回数据
    Java 服务端已构建好的响应，从用户缓冲区写入系统缓冲区
5. 发送给客户端
    Linux 内核通过网络I/O，将内核缓冲区中的数据，写入网卡，网卡通过底层的通讯协议，会将数据发送给目标客户端。

