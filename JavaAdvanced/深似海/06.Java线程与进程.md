# Java线程与进程

------

## 本节概述

- 学习并思考 Java 线程与进程

## 主要内容

### 进程、线程、协程

**进程**，是程序真正的运行实例。

**线程**，是进程中的实际运作单位。

协程，有可能不会开辟新的线程，可能不会出现上下文切换

Java 线程编程模型

- < Java 5：Thread、Runnable
- Java 5：Executor、Future、Callable
- Java 7：ForkJoin
- Java 8：CompletionStage、CompletableFuture
- Java 9：Flow（Publisher、Subscriber、Subscription、Processor）

Java 线程池

- < Java 5：自定义 Thread Pool
- Java 5+：ExecutorService
    - ThreadPoolExecutor
    - ScheduledThreadPoolExecutor
- Java 7+：ForkJoinPool

Java 并发框架

- Java 5：Java Util Concurrent
- Java 7：Fork/Join
- Java 8：CompletableFuture、RxJava、Reactor
- Java 9：Flow API、Reactive Streams



同步

最常见的编程手段，是指任务发起方和执行方在同一线程中完成

异步

常见的提升吞吐手段，是指任务发起方和执行方在不同线程中完成

IO密集型使用并发反而效果不好

非阻塞

一种编程模型，由通知状态被动的回调执行，同步或异步执行均可。比如 NIO



### Java 线程状态

- NEW：线程已创建，尚未启动

    此时操作系统是否启动线程

    ```java
    public Thread(ThreadGroup group, Runnable target, String name, long stackSize) {
        this(group, target, name, stackSize, null, true);
    }
    ```

    

- RUNNABLE：表示线程处于可运行状态，不代表一定运行

- BLOCKED：被 Monitor 锁阻塞，表示当前线程在同步锁的场景运作

- WAITTING：线程处于等待状态，由 Object#wait()、Thread#join() 或 LockSupport#park() 引起

- TIMED_WAITTING：线程处于规定时间内的等待状态

- TERMINATED：线程执行结束



```java
class ThreadDemo {
    public static void main(String[] args) {
        // 如果没有传递 Runnable 对象实现，空执行
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.printf("线程 [Id : %s] : Hello,World!\n", Thread.currentThread().getId());
            }
        });
        thread.start(); // 启动线程
        thread.join(); // 等待线程结束
    }

    public static void main(String[] args) {
        // 如果没有传递 Runnable 对象实现，空执行
        // 使用方法引用
        Thread thread = new Thread(ThreadDemo::sayHelloWorld);
        thread.start();
    }

    public static void sayHelloWorld() {
        System.out.printf("线程 [Id : %s] : Hello,World!\n", Thread.currentThread().getId());
    }
}

```











## 本节总结



## 知识拓展

### 相关文章推荐

### 知识点拓展

1. 

