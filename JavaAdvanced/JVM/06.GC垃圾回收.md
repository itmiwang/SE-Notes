# GC垃圾回收

------

## 本节概述

了解并掌握GC垃圾回收

## 主要内容

### GC的一般原理

首先，GC 垃圾回收，垃圾指的是死亡的对象所占据的堆空间，将这些已经分配出去但却不再使用的内存回收回来，以便能够再次分配的操作，就是垃圾回收。 

那么，紧接着我们就需要了解一下，如何判断一个对象是死亡的。 

#### 引用计数法

引用计数法（reference counting），它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。（我们需要截获所有的引用更新操作，并且相应地增减目标对象的引用计数器。） 

除了需要额外的空间来存储计数器，以及繁琐的更新操作，引用计数法还有一个重大的漏洞，那便是无法处理循环引用对象。循环引用对象实际已经死了，但是引用计数却认为他们还活着，所占据的空间将不可回收，从而造成了内存泄露。 

引用计数->引用跟踪不用标记所有的对象 

#### 可达性分析（主流）

这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。

那么什么是 GC Roots 呢？暂时先理解为堆外指向堆内的引用

1. 当前正在执行的方法里的局部变量和输入参数
2. 活动线程（Active threads）
3. 所有类的静态字段（static field）
4. JNI 引用

可达性分析可以解决引用计数法所不能解决的循环引用的问题。只要从 GC Roots 无法到达两个互相引用的对象，那么它们就不会加入存活对象合集之中。

**主要是通过枚举GC Roots作为根节点出发，能够遍历到的就是任然可以存活的对象。**

在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为 null）或者漏报（将引用设置为未被访问过的对象）。其中漏报比较麻烦，垃圾回收器可能回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致 Java 虚拟机崩溃。 

那么，该如何解决这个问题呢？在 Java 虚拟机里，传统的垃圾回收算法采用的是一种简单粗暴的方式，那便是STW（Stop-the-world），停止其他非垃圾回收线程的工作，直到完成垃圾回收。

##### STW

Java 虚拟机中的 Stop-the-world 是通过安全点（safepoint）机制来实现的。当 Java 虚拟机收到 Stop-the-world 请求，它便会等待所有的线程都到达安全点，才允许请求 Stop-the-world 的线程进行独占的工作。 

##### 安全点机制 -- 待补充





### 垃圾回收三种方式

#### 标记-清除算法（Mark and Sweep）

把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表中（free list）。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。

优点：基础简单

缺点：

- 第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。
- 第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。（由于 Java 虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。）

<img src="picture/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210223163249298.png" alt="image-20210223163249298" style="zoom:50%;" />

#### 标记-复制算法

即把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。

优点：实现简单，运行高效，没有空间碎片

缺点：将可用内存缩小为了原来的一半，空间浪费未免太多了一点

<img src="picture/06.GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210223163147880.png" alt="image-20210223163147880" style="zoom: 50%;" />

#### 标记-清除-整理算法

把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间，然后直接清理掉边界以外的内存。

优点：没有空间碎片，空间利用率高

缺点：移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行

<img src="picture/06.GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210223163229763.png" alt="image-20210223163229763" style="zoom:50%;" />





![image-20210225151843462](picture/06.GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210225151843462.png)



### 常用的组合

1. Serial+Serial Old 实现单线程的低延迟垃圾回收机制；
2. ParNew+CMS，实现多线程的低延迟垃圾回收机制；
3. Parallel Scavenge和Parallel Scavenge Old，实现多线程的高吞吐量垃圾回收机制； 

### 如何选择 GC

选择正确的 GC 算法，唯一可行的方式就是去尝试，一般性的指导原则：

1. 如果系统考虑吞吐优先， CPU 资源都用来最大程度处理业务，用 Parallel GC；
2. 如果系统考虑低延迟有限，每次 GC 时间尽量短，用 CMS GC；
3. 如果系统内存堆较大，同时希望整体来看平均 GC 时间可控，使用 G1 GC。

对于内存大小的考量：

1. 一般 4G 以上，算是比较大，用 G1 的性价比较高。
2. 一般超过 8G，比如 16G-64G 内存，非常推荐使用 G1 GC。

JDK8 的默认 GC 是什么？JDK9， JDK10， JDK11…等等默认的是 GC 是什么？



## 本节总结

针对新生代的垃圾回收器共有三个：Serial，Parallel Scavenge 和 Parallel New。这三个采用的都是标记 - 复制算法。其中，Serial 是一个单线程的，Parallel New 可以看成 Serial 的多线程版本。Parallel Scavenge 和 Parallel New 类似，但更加注重吞吐率。此外，Parallel Scavenge 不能与 CMS 一起使用。

针对老年代的垃圾回收器也有三个：刚刚提到的 Serial Old 和 Parallel Old，以及 CMS。Serial Old 和 Parallel Old 都是标记 - 压缩算法。同样，前者是单线程的，而后者可以看成前者的多线程版本。

CMS 采用的是标记 - 清除算法，并且是并发的。除了少数几个操作需要 Stop-the-world 之外，它可以在应用程序运行过程中进行垃圾回收。在并发收集失败的情况下，Java 虚拟机会使用其他两个压缩型垃圾回收器进行一次垃圾回收。由于 G1 的出现，CMS 在 Java 9 中已被废弃。

G1（Garbage First）是一个横跨新生代和老年代的垃圾回收器。实际上，它已经打乱了前面所说的堆结构，直接将堆分成极其多个区域。每个区域都可以充当 Eden 区、Survivor 区或者老年代中的一个。它采用的是标记 - 压缩算法，而且和 CMS 一样都能够在应用程序运行过程中并发地进行垃圾回收。

G1 能够针对每个细分的区域来进行垃圾回收。在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。这也是 G1 名字的由来。

## 知识拓展

### 相关文章推荐

http://rednaxelafx.iteye.com/blog/1042471
http://rednaxelafx.iteye.com/blog/174865
http://rednaxelafx.iteye.com/blog/1044951

### 知识点拓展

