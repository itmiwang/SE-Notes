# GC垃圾回收

------

## 本节概述

了解并掌握GC垃圾回收

## 主要内容

### GC的一般原理

首先，GC 垃圾回收，垃圾指的是死亡的对象所占据的堆空间，将这些已经分配出去但却不再使用的内存回收回来，以便能够再次分配的操作，就是垃圾回收。 

那么，紧接着我们就需要了解一下，如何判断一个对象是死亡的。 

#### 引用计数法

引用计数法（reference counting），它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。（我们需要截获所有的引用更新操作，并且相应地增减目标对象的引用计数器。） 

除了需要额外的空间来存储计数器，以及繁琐的更新操作，引用计数法还有一个重大的漏洞，那便是无法处理循环引用对象。循环引用对象实际已经死了，但是引用计数却认为他们还活着，所占据的空间将不可回收，从而造成了内存泄露。 

引用计数->引用跟踪不用标记所有的对象 

#### 可达性分析（主流）

这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。

那么什么是 GC Roots 呢？暂时先理解为堆外指向堆内的引用

1. 当前正在执行的方法里的局部变量和输入参数
2. 活动线程（Active threads）
3. 所有类的静态字段（static field）
4. JNI 引用

可达性分析可以解决引用计数法所不能解决的循环引用的问题。只要从 GC Roots 无法到达两个互相引用的对象，那么它们就不会加入存活对象合集之中。

**主要是通过枚举GC Roots作为根节点出发，能够遍历到的就是任然可以存活的对象。**

在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为 null）或者漏报（将引用设置为未被访问过的对象）。其中漏报比较麻烦，垃圾回收器可能回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致 Java 虚拟机崩溃。 

那么，该如何解决这个问题呢？在 Java 虚拟机里，传统的垃圾回收算法采用的是一种简单粗暴的方式，那便是STW（Stop-the-world），停止其他非垃圾回收线程的工作，直到完成垃圾回收。

##### STW

Java 虚拟机中的 Stop-the-world 是通过安全点（safepoint）机制来实现的。当 Java 虚拟机收到 Stop-the-world 请求，它便会等待所有的线程都到达安全点，才允许请求 Stop-the-world 的线程进行独占的工作。 

##### 安全点机制 -- 待补充





### 垃圾回收三种方式

#### 标记-清除算法（Mark and Sweep）

把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表中（free list）。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。

优点：基础简单

缺点：

- 第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。
- 第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。（由于 Java 虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。）

<img src="picture/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210223163249298.png" alt="image-20210223163249298" style="zoom:50%;" />

#### 标记-复制算法

即把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。

优点：实现简单，运行高效，没有空间碎片

缺点：将可用内存缩小为了原来的一半，空间浪费未免太多了一点

<img src="picture/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210223163147880.png" alt="image-20210223163147880" style="zoom: 50%;" />

#### 标记-清除-整理算法

把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间，然后直接清理掉边界以外的内存。

优点：没有空间碎片，空间利用率高

缺点：移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行

<img src="picture/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210223163229763.png" alt="image-20210223163229763" style="zoom:50%;" />



## 知识拓展

### 相关文章推荐



### 知识点拓展

